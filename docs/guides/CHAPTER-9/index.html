<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://github.com/accenture/mercury-composable/guides/CHAPTER-9/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Chapter-9 - Composable for Java</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Chapter-9";
        var mkdocs_page_input_path = "guides/CHAPTER-9.md";
        var mkdocs_page_url = "/accenture/mercury-composable/guides/CHAPTER-9/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Composable for Java
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../METHODOLOGY/">Methodology</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-1/">Chapter-1</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-2/">Chapter-2</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-3/">Chapter-3</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-4/">Chapter-4</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-5/">Chapter-5</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-6/">Chapter-6</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-7/">Chapter-7</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CHAPTER-8/">Chapter-8</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Chapter-9</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#main-application">Main Application</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#setup-before-the-main-application">Setup before the Main Application</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#event-envelope">Event envelope</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pojo-transport">PoJo transport</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#list-of-pojo-transport">List of Pojo transport</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pojo-deserialization-hints">PoJo deserialization hints</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#custom-exception-using-appexception">Custom exception using AppException</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#defining-a-user-function-in-java">Defining a user function in Java</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#inspect-event-metadata">Inspect event metadata</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#platform-api">Platform API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#register-a-function">Register a function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#what-is-a-public-function">What is a public function?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#release-a-function">Release a function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#check-if-a-function-is-available">Check if a function is available</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#wait-for-a-function-to-be-ready">Wait for a function to be ready</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#obtain-the-unique-application-instance-id">Obtain the unique application instance ID</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#set-application-personality">Set application personality</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#postoffice-api">PostOffice API</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#send-an-asynchronous-event-to-a-function">Send an asynchronous event to a function</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#make-an-asynchronous-rpc-call">Make an asynchronous RPC call</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#perform-a-fork-n-join-rpc-call-to-multiple-functions">Perform a fork-n-join RPC call to multiple functions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#make-a-sequential-non-blocking-rpc-call">Make a sequential non-blocking RPC call</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#check-if-a-function-with-a-named-route-exists">Check if a function with a named route exists</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#retrieve-trace-id-and-path">Retrieve trace ID and path</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#trace-annotation">Trace annotation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#configuration-api">Configuration API</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#custom-serializer">Custom serializer</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#minimalist-api-design">Minimalist API design</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#event-scripting">Event Scripting</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#co-existence-with-other-development-frameworks">Co-existence with other development frameworks</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#application-template-for-quick-start">Application template for quick start</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#source-code-update-frequency">Source code update frequency</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#technical-support">Technical support</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../APPENDIX-I/">Appendix-I</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../APPENDIX-II/">Appendix-II</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../APPENDIX-III/">Appendix-III</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG/">Release notes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../arch-decisions/DESIGN-NOTES/">Design notes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../INCLUSIVITY/">Inclusivity</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../CODE_OF_CONDUCT/">Code of Conduct</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../CONTRIBUTING/">Contribution</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../TABLE-OF-CONTENTS/">Contents</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Composable for Java</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Chapter-9</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api-overview">API Overview</h1>
<h2 id="main-application">Main Application</h2>
<p>Each application has an entry point. You may implement an entry point in a main application like this:</p>
<pre><code class="language-java">@MainApplication
public class MainApp implements EntryPoint {

   public static void main(String[] args) {
      AutoStart.main(args);
   }

   @Override
   public void start(String[] args) {
        // your startup logic here
      log.info(&quot;Started&quot;);
   }
}
</code></pre>
<p>In your main application, you must implement the <code>EntryPoint</code> interface to override the "start" method.
Typically, a main application is used to initiate some application start up procedure.</p>
<p>In some case when your application does not need any start up logic, you can just print a message to indicate
that your application has started.</p>
<p>You may want to keep the static "main" method which can be used to run your application inside an IDE.</p>
<p>The pom.xml build script is designed to run the <code>AutoStart</code> class that will execute your main application's
start method.</p>
<p>In some case, your application may have more than one main application module. You can decide the sequence of
execution using the "sequence" parameter in the <code>MainApplication</code> annotation. The module with the smallest
sequence number will run first. Duplicated sequence numbers are allowed. Normal startup sequence must be
between 1 and 999.</p>
<p><em>Note</em>: It is the "start" method of each EntryPoint implementation that follows the execution sequence of the
<code>MainApplication</code> annotation. The optional "main" method is used only to kick off the application bootstrap and
it must include only the following statement:</p>
<pre><code class="language-java">public static void main(String[] args) {
    AutoStart.main(args);
}
</code></pre>
<p>Therefore, even when the default sequence of the <code>MainApplication</code> annotation is 10 and you invoke the "main"
method from an IDE, the "start" method of each MainApplication modules will execute orderly.</p>
<h2 id="setup-before-the-main-application">Setup before the Main Application</h2>
<p>Sometimes, it may be required to set up some environment configuration before your main application starts.
You can implement a <code>BeforeApplication</code> module. Its syntax is similar to the <code>MainApplication</code>.</p>
<pre><code class="language-java">@BeforeApplication
public class EnvSetup implements EntryPoint {

   @Override
   public void start(String[] args) {
        // your environment setup logic here
      log.info(&quot;initialized&quot;);
   }
}
</code></pre>
<p>The <code>BeforeApplication</code> logic will run before your <code>MainApplication</code> module(s). This is useful when you want to do
special handling of environment variables. For example, decrypt an environment variable secret, construct an X.509
certificate, and save it in the "/tmp" folder before your main application starts.</p>
<blockquote>
<p><em>Note</em>: Sequence 0 is reserved by the EssentialServiceLoader and 2 reserved by Event Script.
          Your user functions should use a number between 3 and 999.</p>
</blockquote>
<h2 id="event-envelope">Event envelope</h2>
<p>Mercury is an event engine that encapsulates Eclipse Vertx and Java 21 virtual thread technology.</p>
<p>A composable application is a collection of functions that communicate with each other in events.
Each event is transported by an event envelope. Let's examine the envelope.</p>
<p>There are 3 elements in an event envelope:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Element</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: left;">metadata</td>
<td style="text-align: left;">Includes unique ID, target function name, reply address<br/> correlation ID, status, exception, trace ID and path</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: left;">headers</td>
<td style="text-align: left;">User defined key-value pairs</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: left;">body</td>
<td style="text-align: left;">Event payload (primitive, hash map or PoJo)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>Note</em>: Headers and body are optional, but you should provide at least one of them.</p>
</blockquote>
<h2 id="pojo-transport">PoJo transport</h2>
<p>Your function can implement the TypedLambdaFunction interface if you want to use PoJo as input and output
and the system will restore PoJo payload accordingly.</p>
<p>However, if you use the EventEnvelope as an input in the TypedLambdaFunction, PoJo payload is mapped as a HashMap
in the event's body.</p>
<p>The original class name of the PoJo payload is saved in the event's type attribute.
You can compare and restore the PoJo like this:</p>
<pre><code class="language-java">if (SamplePoJo.class.getName().equals(input.getType())) {
    SamplePoJo pojo = input.getBody(SamplePoJo.class);
    // do something with your input PoJo
}
</code></pre>
<h2 id="list-of-pojo-transport">List of Pojo transport</h2>
<p>When sending events programmatically, you can send a list of PoJo to a user function. However, the list of pojo
will be converted as a list of maps as input to the target function.</p>
<p>Since type information is lost at runtime, you may add the <code>inputPojoClass</code> parameter in the <code>PreLoad</code> annotation
of the target function. The system will then render the list of pojo as input to the target function.</p>
<p>This applies to both untyped <code>LambdaFunction</code> and <code>TypedLambdaFunction</code>. In untyped LambdaFunction, the input is
an object. In TypedLambdaFunction, you should configure the input as list of pojo and add the "inputPojoClass"
hint in the PreLoad annotation. For example, the following unit test illustrates this:</p>
<pre><code class="language-java">@PreLoad(route = &quot;input.list.of.pojo.java&quot;, inputPojoClass = PoJo.class)
public class InputAsListOfPoJo implements TypedLambdaFunction&lt;List&lt;PoJo&gt;, Object&gt; {
    @Override
    public Object handleEvent(Map&lt;String, String&gt; headers, List&lt;PoJo&gt; input, int instance) throws Exception {
        List&lt;String&gt; names = new ArrayList&lt;&gt;();
        // prove that the list of pojo is correctly deserialized
        for (PoJo o: input) {
            if (o != null) {
                names.add(o.getName());
            } else {
                names.add(&quot;null&quot;);
            }
        }
        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;names&quot;, names);
        return result;
    }
}
</code></pre>
<blockquote>
<p><em>Note</em>: List of PoJo as input to a composable function is not supported by input data mapping
          of Event Script. This is only allowed when sending events programmatically for certain
          use cases.</p>
</blockquote>
<h2 id="pojo-deserialization-hints">PoJo deserialization hints</h2>
<p>The PoJo class definition in the TypedLambdaFunction has precedence over the "inputPojoClass" hint
in the PreLoad annotation.</p>
<p>For PoJo transport, the "inputPojoClass" parameter in the PreLoad annotation will only be used
when the untyped "LambdaFunction" is declared. This is for backward compatibility with
legacy version 2 and 3 where pojo transport restores pojo as input to user function written as
untyped LambdaFunction.</p>
<p>The list of pojo is handled differently as a deserialization hint in both the untyped LambdaFunction
and the TypedLambdaFunction use cases as discussed earlier.</p>
<h2 id="custom-exception-using-appexception">Custom exception using AppException</h2>
<p>To reject an incoming request, you can throw an AppException like this:</p>
<pre><code class="language-java">// example-1
throw new AppException(400, &quot;My custom error message&quot;);
// example-2
throw new AppException(400, &quot;My custom error message&quot;, ex);
</code></pre>
<p>Example-1 - a simple exception with status code (400) and an error message</p>
<p>Example-2 - includes a nested exception</p>
<p>As a best practice, we recommend using error codes that are compatible with HTTP status codes.</p>
<h2 id="defining-a-user-function-in-java">Defining a user function in Java</h2>
<p>You can write a function in Java like this:</p>
<pre><code class="language-java">@PreLoad(route = &quot;hello.simple&quot;, instances = 10)
public class SimpleDemoEndpoint implements TypedLambdaFunction&lt;AsyncHttpRequest, Object&gt; {
    @Override
    public Object handleEvent(Map&lt;String, String&gt; headers, AsyncHttpRequest input, int instance) {
        // business logic here
        return result;
    }
}
</code></pre>
<p>The <code>PreLoad</code> annotation tells the system to preload the function into memory and register it into the event loop.
You must provide a "route name" and configure the number of concurrent workers ("instances").</p>
<p>Route name is used by the event loop to find your function in memory. A route name must use lower letters and numbers,
and it must have at least one dot as a word separator. e.g. "hello.simple" is a proper route name but "HelloSimple" 
is not.</p>
<p>You can implement your function using the LambdaFunction or TypedLambdaFunction. The latter allows you to define
the input and output classes.</p>
<p>The system will map the event body into the <code>input</code> argument and the event headers into the <code>headers</code> argument.
The <code>instance</code> argument informs your function which worker is serving the current request.</p>
<p>Optionally, you can specify an <code>envInstances</code> parameter. This tells the system to use a parameter from the 
application.properties (or application.yml) to configure the number of workers for the function. When the parameter
defined in "envInstances" is not found, the "instances" parameter is used as the default value.</p>
<p>You can override special services such as <code>no.op</code>, <code>reslience.handler</code>, and <code>simple.exception.handler</code> using the
following properties:</p>
<ul>
<li><code>worker.instances.no.op</code></li>
<li><code>worker.instances.resilience.handler</code></li>
<li><code>worker.instances.simple.exception.handler</code></li>
</ul>
<h2 id="inspect-event-metadata">Inspect event metadata</h2>
<p>There are some reserved metadata such as route name ("my_route"), trace ID ("my_trace_id") and trace path
("my_trace_path") in the "headers" argument. They do not exist in the incoming event envelope. Instead,
the system automatically insert them as read-only metadata.</p>
<p>They are used to create a trackable instance of the PostOffice. e.g.</p>
<pre><code class="language-java">var po = PostOffice.trackable(headers, instance);
</code></pre>
<p>To inspect all metadata, you can declare the input as "EventEnvelope" in a TypedLambdaFunction. The system will
map the whole event envelope into the "input" argument. You can retrieve the replyTo address and other useful items.</p>
<blockquote>
<p><em>Note</em>: The "replyTo" address is optional. It is only required when the caller is making an RPC call.
          If the caller sends an asynchronous request, the "replyTo" value is null.</p>
</blockquote>
<h2 id="platform-api">Platform API</h2>
<p>You can obtain a singleton instance of the Platform object to do the following:</p>
<h3 id="register-a-function">Register a function</h3>
<p>We recommend using the <code>PreLoad</code> annotation in a class to declare the function route name, number of worker instances
and whether the function is public or private.</p>
<p>In some use cases where you want to create and destroy functions on demand, you can register them programmatically.</p>
<p>In the following example, it registers "my.function" using the MyFunction class as a public function and 
"another.function" with the AnotherFunction class as a private function.</p>
<pre><code class="language-java">Platform platform = Platform.getInstance();

// register a public function
platform.register(&quot;my.function&quot;, new MyFunction(), 10);

// register a private function
platform.registerPrivate(&quot;another.function&quot;, new AnotherFunction(), 20);
</code></pre>
<h3 id="what-is-a-public-function">What is a public function?</h3>
<p>A public function is visible by any application instances in the same network. When a function is declared as
"public", the function is reachable through the Event-over-HTTP REST endpoint or a service mesh.</p>
<p>A private function is invisible outside the memory space of the application instance that it resides.
This allows application to encapsulate business logic according to domain boundary. You can assemble closely
related functions as a composable application that can be deployed independently.</p>
<h3 id="release-a-function">Release a function</h3>
<p>In some use cases, you want to release a function on-demand when it is no longer required.</p>
<pre><code class="language-text">platform.release(&quot;another.function&quot;);
</code></pre>
<p>The above API will unload the function from memory and release it from the "event loop".</p>
<h3 id="check-if-a-function-is-available">Check if a function is available</h3>
<p>You can check if a function with the named route has been deployed.</p>
<pre><code class="language-text">if (platform.hasRoute(&quot;another.function&quot;)) {
    // do something
}
</code></pre>
<h3 id="wait-for-a-function-to-be-ready">Wait for a function to be ready</h3>
<p>Functions are registered asynchronously. For functions registered using the <code>PreLoad</code> annotation, they are available
to your application when the MainApplication starts.</p>
<p>For functions that are registered on-demand, you can wait for the function to get ready like this:</p>
<pre><code class="language-text">platform.waitForProvider(&quot;cloud.connector&quot;, 10)
        .onSuccess(ready -&gt; {
            // business logic when &quot;cloud.connector&quot; is ready 
        });
</code></pre>
<p>Note that the "onFailure" method is not required. The onSuccess will return true or false. In the above example,
your application waits for up to 10 seconds. If the function (i.e. the "provider") is available, the API will invoke
the "onSuccess" method immediately.</p>
<h3 id="obtain-the-unique-application-instance-id">Obtain the unique application instance ID</h3>
<p>When an application instance starts, a unique ID is generated. We call this the "Origin ID".</p>
<pre><code class="language-java">var originId = po.getOrigin();
</code></pre>
<p>When running the application in a minimalist service mesh using Kafka or similar network event stream system,
the origin ID is used to uniquely identify the application instance.</p>
<p>The origin ID is automatically appended to the "replyTo" address when making a RPC call over a network event stream
so that the system can send the response event back to the "originator" or "calling" application instance.</p>
<h3 id="set-application-personality">Set application personality</h3>
<p>An application may have one of the following personality:</p>
<ol>
<li>REST - the deployed application is user facing</li>
<li>APP - the deployed application serves business logic</li>
<li>RESOURCES - this is a resource-tier service. e.g. database service, MQ gateway, legacy service proxy, utility, etc.</li>
</ol>
<p>You can change the application personality like this:</p>
<pre><code class="language-text">// the default value is &quot;APP&quot;
ServerPersonality.getInstance().setType(ServerPersonality.Type.REST);
</code></pre>
<p>The personality setting is for documentation purpose only. It does not affect the behavior of your application.
It will appear in the application "/info" endpoint.</p>
<h2 id="postoffice-api">PostOffice API</h2>
<p>You can obtain an instance of the PostOffice from the input "headers" and "instance" parameters in the input
arguments of your function.</p>
<pre><code class="language-java">var po = PostOffice.trackable(headers, instance);
</code></pre>
<p>The PostOffice is the event manager that you can use to send asynchronous events or to make RPC requests.
The constructor uses the READ only metadata in the "headers" argument in the "handleEvent" method of your function.</p>
<p>For end-to-end traceability, please use the PostOffice instance to make requests to a composable library.
It maintains the same traceId and tracePath in the traceability graph. If your handleEvent method calls another
method in your class, you should pass this PostOffice instance so that any event calls from the other method
can propagate the tracing information.</p>
<p>For Unit Tests, since a test does not start with the handleEvent of a LambdaFunction, you can use the following
to create a PostOffice with your own traceId. The "myRoute" is the caller's route name. In this case, you can
set it to "unit.test".</p>
<pre><code class="language-java">public PostOffice(String myRoute, String myTraceId, String myTracePath);
</code></pre>
<h3 id="send-an-asynchronous-event-to-a-function">Send an asynchronous event to a function</h3>
<p>You can send an asynchronous event like this.</p>
<pre><code class="language-java">// example-1
po.send(&quot;another.function&quot;, &quot;test message&quot;);

// example-2
po.send(&quot;another.function&quot;, new Kv(&quot;some_key&quot;, &quot;some_value&quot;), new kv(&quot;another_key&quot;, &quot;another_value&quot;));

// example-3
po.send(&quot;another.function&quot;, somePoJo, new Kv(&quot;some_key&quot;, &quot;some_value&quot;));

// example-4
EventEnvelope event = new EventEnvelope().setTo(&quot;another.function&quot;)
                            .setHeader(&quot;some_key&quot;, &quot;some_value&quot;).setBody(somePoJo);
po.send(event)

// example-5
po.sendLater(event, new Date(System.currentTimeMillis() + 5000));
</code></pre>
<ol>
<li>Example-1 sends the text string "test message" to the target service named "another.function".</li>
<li>Example-2 sends two key-values as "headers" parameters to the same service.</li>
<li>Example-3 sends a PoJo and a key-value pair to the same service.</li>
<li>Example-4 is the same as example-3. It is using an EventEnvelope to construct the request.</li>
<li>Example-5 schedules an event to be sent 5 seconds later.</li>
</ol>
<p>The first 3 APIs are convenient methods and the system will automatically create an EventEnvelope to hold the
target route name, key-values and/or event payload.</p>
<h3 id="make-an-asynchronous-rpc-call">Make an asynchronous RPC call</h3>
<p>You can make RPC call like this:</p>
<pre><code class="language-java">// example-1
EventEnvelope request = new EventEnvelope().setTo(&quot;another.function&quot;)
                            .setHeader(&quot;some_key&quot;, &quot;some_value&quot;).setBody(somePoJo);
Future&lt;EventEnvelope&gt; response = po.asyncRequest(request, 5000);
response.onSuccess(result -&gt; {
    // result is the response event
});
response.onFailure(e -&gt; {
    // handle timeout exception
});

// example-2
Future&lt;EventEnvelope&gt; response = po.asyncRequest(request, 5000, false);
response.onSuccess(result -&gt; {
    // result is the response event
    // Timeout exception is returned as a response event with status=408
});

// example-3 with the &quot;rpc&quot; boolean parameter set to true
Future&lt;EventEnvelope&gt; response = po.asyncRequest(request, 5000, &quot;http://peer/api/event&quot;, true);
response.onSuccess(result -&gt; {
    // result is the response event
});
response.onFailure(e -&gt; {
    // handle timeout exception
});
</code></pre>
<ol>
<li>Example-1 makes a RPC call with a 5-second timeout to "another.function".</li>
<li>Example-2 sets the "timeoutException" to false, telling system to return timeout exception as a regular event.</li>
<li>Example-3 makes an "event over HTTP" RPC call to "another.function" in another application instance called "peer".</li>
</ol>
<p>"Event over HTTP" is an important topic. Please refer to <a href="../CHAPTER-7/">Chapter 7</a> for more details.</p>
<h3 id="perform-a-fork-n-join-rpc-call-to-multiple-functions">Perform a fork-n-join RPC call to multiple functions</h3>
<p>In a similar fashion, you can make a fork-n-join call that sends request events in parallel to more than one function.</p>
<pre><code class="language-java">// example-1
EventEnvelope request1 = new EventEnvelope().setTo(&quot;this.function&quot;)
                            .setHeader(&quot;hello&quot;, &quot;world&quot;).setBody(&quot;test message&quot;);
EventEnvelope request2 = new EventEnvelope().setTo(&quot;that.function&quot;)
                            .setHeader(&quot;good&quot;, &quot;day&quot;).setBody(somePoJo);
List&lt;EventEnvelope&gt; requests = new ArrayList&lt;&gt;();
requests.add(request1);
requests.add(request2);
Future&lt;List&lt;EventEnvelope&gt;&gt; responses = po.asyncRequest(requests, 5000);
response.onSuccess(results -&gt; {
    // results contains the response events
});
response.onFailure(e -&gt; {
    // handle timeout exception
});

// example-2
Future&lt;List&lt;EventEnvelope&gt;&gt; responses = po.asyncRequest(requests, 5000, false);
response.onSuccess(results -&gt; {
    // results contains the response events.
    // Partial result list is returned if one or more functions did not respond.
});
</code></pre>
<h3 id="make-a-sequential-non-blocking-rpc-call">Make a sequential non-blocking RPC call</h3>
<p>You can make a sequential non-blocking RPC call from one function to another.</p>
<p>The most convenient method to make a sequential non-blocking RPC call is to use the PostOffice's request API.</p>
<pre><code class="language-java">// for a single RPC call
PostOffice po = PostOffice.trackable(headers, instance);
EventEnvelope result = po.request(requestEvent, timeoutInMills).get();

// for a fork-n-join call
PostOffice po = PostOffice.trackable(headers, instance);
List&lt;EventEnvelope&gt; result = po.request(requestEvents, timeoutInMills).get();
</code></pre>
<blockquote>
<p><em>Note</em>: the "eRequest" is a reactive version of the above "request" methods. Its return type is
          a CompletableFuture, thus allowing the use of "nextAccept" method to process result asynchronously.</p>
</blockquote>
<h3 id="check-if-a-function-with-a-named-route-exists">Check if a function with a named route exists</h3>
<p>The PostOffice provides the "exists()" method that is similar to the "platform.hasRoute()" command.</p>
<p>The difference is that the "exists()" method can discover functions of another application instance when running
in the "service mesh" mode.</p>
<p>If your application is not deployed in a service mesh, the PostOffice's "exists" and Platform's "hasRoute" APIs
will provide the same result.</p>
<pre><code class="language-java">boolean found = po.exists(&quot;another.function&quot;);
if (found) {
    // do something
}
</code></pre>
<h3 id="retrieve-trace-id-and-path">Retrieve trace ID and path</h3>
<p>If you want to know the route name and optional trace ID and path, you can use the following APIs.</p>
<p>For example, if tracing is enabled, the trace ID will be available. You can put the trace ID in application log
messages. This would group log messages of the same transaction together when you search the trace ID from 
a centralized logging dashboard such as Splunk.</p>
<pre><code class="language-java">String myRoute = po.getRoute();
String traceId = po.getTraceId();
String tracePath = po.getTracePath();
</code></pre>
<h2 id="trace-annotation">Trace annotation</h2>
<p>To annotate additional information in the trace of your function, please obtain a trackable PostOffice
instance using <code>PostOffice.trackable(headers, instance)</code> and follow the following API signatures:</p>
<pre><code class="language-java">// API signatures
public PostOffice annotateTrace(String key, String value);
public PostOffice annotateTrace(String key, Map&lt;String, Object&gt; value);
public PostOffice annotateTrace(String key, List&lt;Object&gt; value);

// For example,
var po = PostOffice.trackable(headers, instance);
po.annotateTrace(&quot;hello&quot;, &quot;world&quot;);
</code></pre>
<p>Annotations of key-values, if any, will be recorded in the trace and they are not accessible by
another function.</p>
<p>Please be moderate to attach only <em>small amount of transaction specific information</em> to the
performance metrics of your functions.</p>
<blockquote>
<p><em>Note</em>: Don't annotate sensitive information or secrets such as PII, PHI, PCI data because 
          the trace is visible in the application log. It may also be forwarded to a centralized
          telemetry dashboard for visualization and analytics.</p>
</blockquote>
<h2 id="configuration-api">Configuration API</h2>
<p>Your function can access the main application configuration from the platform like this:</p>
<pre><code class="language-java">AppConfigReader config = AppConfigReader.getInstance();
// the value can be string or a primitive
Object value = config.get(&quot;my.parameter&quot;);
// the return value will be converted to a string
String text = config.getProperty(&quot;my.parameter&quot;);
</code></pre>
<p>The system uses the standard dot-bracket format for a parameter name. e.g.</p>
<pre><code class="language-properties">hello.world
some.key[2]
</code></pre>
<p>You can override the main application configuration at run-time using the Java argument "-D". e.g.</p>
<blockquote>
<p>java -Dserver.port=8080 -jar myApp.jar</p>
</blockquote>
<p>Additional configuration files can be added with the <code>ConfigReader</code> constructor like this:</p>
<pre><code class="language-java">// filePath should have location prefix &quot;classpath:/&quot; or &quot;file:/&quot;
ConfigReader reader = new ConfigReader(filePath);
</code></pre>
<p>The configuration system supports environment variable or reference to the main application configuration
using the dollar-bracket syntax <code>${reference:default_value}</code>. e.g.</p>
<pre><code class="language-properties">some.key=${MY_ENV_VARIABLE}
another.key=${my.key:12345}
complex.key=first ${FIRST_ENV_VAR}, second ${SECOND_ENV_VAR}
</code></pre>
<p>In the above example, a parameter may contain references to more than one environment variable.</p>
<p>Default value, if not given, will be assumed to be an empty string.</p>
<h2 id="custom-serializer">Custom serializer</h2>
<p>We are using GSON as the underlying serializer to handle common use cases. However, there may be
situation that you want to use your own custom serialization library.</p>
<p>To do that, you may write a serializer that implements the CustomSerializer interface:</p>
<pre><code class="language-java">public interface CustomSerializer {

    public Map&lt;String, Object&gt; toMap(Object obj);

    public &lt;T&gt; T toPoJo(Object obj, Class&lt;T&gt; toValueType);

}
</code></pre>
<p>You may configure a user function to use a custom serializer by adding the "customSerializer" parameter
in the <code>PreLoad</code> annotation. For example,</p>
<pre><code class="language-java">@PreLoad(route=&quot;my.user.function&quot;, customSerializer = JacksonSerializer.class)
public class MyUserFunction implements TypedLambdaFunction&lt;SimplePoJo, SimplePoJo&gt; {
    @Override
    public SimplePoJo handleEvent(Map&lt;String, String&gt; headers, SimplePoJo input, int instance) {
        return input;
    }
}
</code></pre>
<p>If you register your function dynamically in code, you can use the following <code>platform API</code> to assign
a custom serializer.</p>
<pre><code class="language-java">public void setCustomSerializer(String route, CustomSerializer mapper);
// e.g.
// platform.setCustomSerializer(&quot;my.function&quot;, new JacksonSerializer());
</code></pre>
<p>If you use the PostOffice to programmatically send event or make event RPC call and you need a
custom serializer, you can create a PostOffice instance like this:</p>
<pre><code class="language-java">// this should be the first statement in the &quot;handleEvent&quot; method.
PostOffice po = PostOffice.withSerializer(headers, instance, new MyCustomSerializer());
</code></pre>
<p>The outgoing event using the PostOffice will use the custom serializer automatically.</p>
<p>To interpret an event response from a RPC call, you can use the following PostOffice API:</p>
<pre><code class="language-java">MyPoJo result = po.getEventBodyAsPoJo(responseEvent, MyPoJo.class);
</code></pre>
<h2 id="minimalist-api-design">Minimalist API design</h2>
<p>As a best practice, we advocate a minimalist approach in API integration.
To build powerful composable applications, the above set of APIs is sufficient to perform
"event orchestration" where you write code to coordinate how the various functions work together as a
single "executable". Please refer to <a href="../CHAPTER-4/">Chapter-4</a> for more details about event orchestration. </p>
<p>Since Mercury is used in production installations, we will exercise the best effort to keep the core API stable.</p>
<p>Other APIs in the toolkits are used internally to build the engine itself, and they may change from time to time.
They are mostly convenient methods and utilities. The engine is fully encapsulated and any internal API changes
are not likely to impact your applications.</p>
<h2 id="event-scripting">Event Scripting</h2>
<p>To further reduce coding effort, you can perform "event choreography" by configuration using "Event Script".
Please refer to Event Script syntax in <a href="../CHAPTER-4/">Chapter 4</a></p>
<h2 id="co-existence-with-other-development-frameworks">Co-existence with other development frameworks</h2>
<p>Mercury libraries are designed to co-exist with your favorite frameworks and tools. Inside a class implementing
the <code>LambdaFunction</code> or <code>TypedLambdaFunction</code>, you can use any coding style and frameworks as you like, including
sequential, object-oriented and reactive programming styles.</p>
<p>The core-engine has a built-in lightweight non-blocking HTTP server, but you can also use Spring Boot and other
application server framework with it.</p>
<p>A sample Spring Boot integration is provided in the "rest-spring-3" project. It is an optional feature, and you can
decide to use a regular Spring Boot application with Mercury Composable or to pick the customized Spring Boot in the
"rest-spring-3" library.</p>
<h2 id="application-template-for-quick-start">Application template for quick start</h2>
<p>We recommend using the <code>composable-example</code> project as a template to start writing your own Composable applications.
You can follow the Composable methodology where you draw event flow diagrams to represent various use cases,
convert them into event scripts that carry out event choreography for your self-contained functions.</p>
<p>For more information, please refer to Event Script syntax in <a href="../CHAPTER-4/">Chapter 4</a>.</p>
<p>If you prefer to do low-level event-driven programming, you can use the <code>lambda-example</code> project as a template.
It is preconfigured to support kernel threads and virtual threads.</p>
<h2 id="source-code-update-frequency">Source code update frequency</h2>
<p>This project is licensed under the Apache 2.0 open sources license. We will update the public codebase after
it passes regression tests and meets stability and performance benchmarks in our production systems.</p>
<p>Mercury Composable is developed as an engine for you to build the latest cloud native applications.</p>
<p>Composable technology is evolving rapidly. We would exercise best effort to keep the essential internals
and core APIs stable. Please browse the latest Developer Guide, release notes and Javadoc for any breaking
API changes.</p>
<h2 id="technical-support">Technical support</h2>
<p>For enterprise clients, technical support is available. Please contact your Accenture representative for details.
<br/></p>
<table>
<thead>
<tr>
<th style="text-align: center;">Chapter-8</th>
<th style="text-align: center;">Home</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><a href="../CHAPTER-8/">Minimalist Service Mesh</a></td>
<td style="text-align: center;"><a href="../TABLE-OF-CONTENTS/">Table of Contents</a></td>
</tr>
</tbody>
</table>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../CHAPTER-8/" class="btn btn-neutral float-left" title="Chapter-8"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../APPENDIX-I/" class="btn btn-neutral float-right" title="Appendix-I">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../CHAPTER-8/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../APPENDIX-I/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
