flow:
  id: 'parallel-test'
  description: 'Test parallel processing'
  ttl: 1s

first.task: 'begin.parallel.test'

tasks:
  - input:
      - 'int(2) -> count'
    process: 'begin.parallel.test'
    output: []
    description: 'Setup counter for two parallel tasks'
    execution: parallel
    next:
      - 'parallel.one'
      - 'parallel.two'

  - name: 'parallel.one'
    input:
      - 'text(hello-world-one) -> key1'
    process: 'parallel.task'
    output:
      - 'result.key1 -> model.key1'
      - 'result.decision -> decision'
    description: 'Hello world'
    execution: decision
    next:
      - 'echo.one'
      - 'echo.two'

  - name: 'parallel.two'
    input:
      - 'text(hello-world-two) -> key2'
    process: 'parallel.task'
    output:
      - 'result.key2 -> model.key2'
      - 'result.decision -> decision'
    description: 'Hello world'
    execution: decision
    next:
      - 'echo.one'
      - 'echo.two'

  #
  # Running parallel tasks requires the flow to be active.
  #
  # For this unit test, we use a bench to keep track of the remaining tasks.
  # echo.one will execute when there are no remaining tasks.
  # Therefore, the execution will come to an end when echo.one finally executes.
  #
  - name: 'echo.one'
    input:
      - 'model.key1 -> key1'
      - 'model.key2 -> key2'
    process: 'no.op'
    output:
      - 'text(application/json) -> output.header.content-type'
      - 'result -> output.body'
    description: 'Hello world'
    execution: end

  - name: 'echo.two'
    input:
      - 'model.key1 -> key1'
      - 'model.key2 -> key2'
    process: 'no.op'
    output: []
    description: 'Hello world'
    execution: sink
